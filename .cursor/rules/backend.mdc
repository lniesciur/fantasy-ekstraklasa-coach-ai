---
description: Backend development guidelines for .NET 8 Fantasy Coach AI application
globs: src/FantasyCoachAI.Application/**/*.cs,src/FantasyCoachAI.Domain/**/*.cs,src/FantasyCoachAI.Infrastructure/**/*.cs,src/FantasyCoachAI.Web/Program.cs
alwaysApply: false
---

### Backend Architecture (.NET 8)

**Clean Architecture Layers**
- Domain: Core business entities and interfaces (no dependencies)
- Application: Business logic, services, DTOs, and use cases
- Infrastructure: Data access, external services, and implementations
- Web: Presentation layer with Blazor Server components

**Dependency Injection**
- Register services in appropriate layers using extension methods
- Use Scoped lifetime for repositories and services
- Use Singleton for configuration and Supabase client
- Always validate configuration in Infrastructure DI
- Use strongly-typed configuration classes with validation
- Register FluentValidation validators automatically with `AddValidatorsFromAssemblyContaining<T>()`

**Supabase Integration**
- Use Supabase.Client as Scoped service, not Singleton
- Always call `await _supabase.InitializeAsync()` before operations
- Use proper Supabase Postgrest attributes for models
- Implement Row Level Security (RLS) policies in database
- Use typed models with BaseModel inheritance
- Configure Supabase options: AutoRefreshToken = true, AutoConnectRealtime = false

**Repository Pattern**
- Implement interfaces in Domain layer
- Use async/await for all database operations
- Handle exceptions gracefully with proper error messages
- Use mappers to convert between domain and database models
- Implement filtering and pagination in repository methods
- Use proper Supabase query patterns with Postgrest

**Service Layer**
- Keep business logic in Application services
- Validate input parameters and throw meaningful exceptions
- Use DTOs for data transfer between layers
- Implement proper error handling and validation
- Keep services focused on single responsibility
- Use FluentValidation for comprehensive input validation

**Configuration**
- Store Supabase settings in appsettings.json with strongly-typed classes
- Use environment-specific configuration files (appsettings.Development.json)
- Validate required settings in DI registration with meaningful error messages
- Use IConfiguration.Bind() for configuration binding
- Include JwtSecret in SupabaseSettings for authentication

**Error Handling & Validation**
- Use ArgumentException for invalid parameters
- Use InvalidOperationException for business rule violations
- Use custom NotFoundException for missing resources
- Implement global exception middleware (ApiExceptionMiddleware)
- Use AutoValidateActionFilter for automatic DTO validation
- Return structured error responses with field-level validation details
- Log errors with structured logging using ILogger<T>

**Database Models & Mapping**
- Use Supabase Postgrest attributes (Table, Column, PrimaryKey)
- Inherit from BaseModel for Supabase compatibility
- Use proper data types and constraints
- Implement proper mapping between domain and database models
- Use dedicated mapper classes for complex transformations

**API Design & Middleware**
- Use global action filters for automatic validation
- Implement CORS for API endpoints
- Use JSON serialization with camelCase naming policy
- Include enum string conversion in JSON serialization
- Use Swagger/OpenAPI for API documentation in development
- Implement proper HTTP status codes and error responses

**Health Checks & Monitoring**
- Implement health check endpoints for monitoring
- Test Supabase connectivity in health checks
- Return proper HTTP status codes (200 for healthy, 503 for unhealthy)
- Include timestamp and service status in responses
- Use structured logging for monitoring and debugging

**Testing & Quality**
- Write unit tests for all layers (Domain, Application, Infrastructure)
- Test dependency injection configuration
- Test validation rules with comprehensive test cases
- Use FluentAssertions for readable test assertions
- Test error scenarios and edge cases
- Mock external dependencies in tests

**Security & Performance**
- Implement Row Level Security (RLS) policies in database
- Use proper authentication and authorization
- Validate all inputs at API boundaries
- Use async/await for all I/O operations
- Implement proper error handling to prevent information leakage
- Use structured logging for security auditing